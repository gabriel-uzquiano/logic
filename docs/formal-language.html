<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="6 Formal Language | Introduction to Logic" />
<meta property="og:type" content="book" />

<meta property="og:description" content="This is a textbook for PHIL 220g. Introduction to Logic." />
<meta name="github-repo" content="rstudio/bookdown-demo" />

<meta name="author" content="Gabriel Uzquiano" />


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<meta name="description" content="This is a textbook for PHIL 220g. Introduction to Logic.">

<title>6 Formal Language | Introduction to Logic</title>

<link href="libs/tufte-css-2015.12.29/tufte-fonts.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-background.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-italics.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />





<link rel="stylesheet" href="toc.css" type="text/css" />
<link rel="stylesheet" href="custom.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#preface" id="toc-preface">Preface</a></li>
<li class="part"><span><b>I Introduction</b></span></li>
<li class="has-sub"><a href="reason.html#reason" id="toc-reason"><span class="toc-section-number">1</span> Reason and Argument</a>
<ul>
<li><a href="reason.html#arguments" id="toc-arguments">Arguments</a></li>
<li><a href="reason.html#validity-and-form" id="toc-validity-and-form">Validity and Form</a></li>
<li><a href="reason.html#formal-languages" id="toc-formal-languages">Formal Languages</a></li>
<li><a href="reason.html#exercises" id="toc-exercises">Exercises</a></li>
</ul></li>
<li class="part"><span><b>II Propositional Logic</b></span></li>
<li class="has-sub"><a href="proplogic.html#proplogic" id="toc-proplogic"><span class="toc-section-number">2</span> Formal Language</a>
<ul>
<li><a href="proplogic.html#quotation-and-metavariables" id="toc-quotation-and-metavariables">Quotation and Metavariables</a></li>
<li><a href="proplogic.html#syntax" id="toc-syntax">Syntax</a></li>
<li><a href="proplogic.html#semantics" id="toc-semantics">Semantics</a></li>
<li><a href="proplogic.html#exercises-1" id="toc-exercises-1">Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="translationproplogic.html#translationproplogic" id="toc-translationproplogic"><span class="toc-section-number">3</span> Translation</a>
<ul>
<li><a href="translationproplogic.html#a-translation-method" id="toc-a-translation-method">A Translation Method</a></li>
<li><a href="translationproplogic.html#issues-with-translation" id="toc-issues-with-translation">Issues with Translation</a></li>
<li><a href="translationproplogic.html#application" id="toc-application">Application</a></li>
<li><a href="translationproplogic.html#exercises-2" id="toc-exercises-2">Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="natdedprop.html#natdedprop" id="toc-natdedprop"><span class="toc-section-number">4</span> Natural Deduction</a>
<ul>
<li><a href="natdedprop.html#natural-deduction-rules" id="toc-natural-deduction-rules">Natural Deduction Rules</a></li>
<li><a href="natdedprop.html#conjunction-and-conditional" id="toc-conjunction-and-conditional">Conjunction and Conditional</a></li>
<li><a href="natdedprop.html#disjunction-and-negation" id="toc-disjunction-and-negation">Disjunction and Negation</a></li>
<li><a href="natdedprop.html#how-to-construct-proofs" id="toc-how-to-construct-proofs">How to Construct Proofs</a></li>
<li><a href="natdedprop.html#exercises-3" id="toc-exercises-3">Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="limits-of-propositional-logic.html#limits-of-propositional-logic" id="toc-limits-of-propositional-logic"><span class="toc-section-number">5</span> Limits of Propositional Logic</a>
<ul>
<li><a href="limits-of-propositional-logic.html#natural-language-and-propositional-logic" id="toc-natural-language-and-propositional-logic">Natural Language and Propositional Logic</a></li>
<li><a href="limits-of-propositional-logic.html#expressive-limitations" id="toc-expressive-limitations">Expressive Limitations</a></li>
<li><a href="limits-of-propositional-logic.html#exercises-4" id="toc-exercises-4">Exercises</a></li>
</ul></li>
<li class="part"><span><b>III Quantificational Logic</b></span></li>
<li class="has-sub"><a href="formal-language.html#formal-language" id="toc-formal-language"><span class="toc-section-number">6</span> Formal Language</a>
<ul>
<li><a href="formal-language.html#syntax-1" id="toc-syntax-1">Syntax</a></li>
<li><a href="formal-language.html#semantics-1" id="toc-semantics-1">Semantics</a></li>
<li><a href="formal-language.html#exercises-5" id="toc-exercises-5">Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="translation.html#translation" id="toc-translation"><span class="toc-section-number">7</span> Translation</a>
<ul>
<li><a href="translation.html#a-translation-method-1" id="toc-a-translation-method-1">A Translation Method</a></li>
<li><a href="translation.html#issues-with-translation-1" id="toc-issues-with-translation-1">Issues with Translation</a></li>
<li><a href="translation.html#exercises-6" id="toc-exercises-6">Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="natural-deduction.html#natural-deduction" id="toc-natural-deduction"><span class="toc-section-number">8</span> Natural Deduction</a>
<ul>
<li><a href="natural-deduction.html#universal-quantification" id="toc-universal-quantification">Universal Quantification</a></li>
<li><a href="natural-deduction.html#existential-quantification" id="toc-existential-quantification">Existential Quantification</a></li>
<li><a href="natural-deduction.html#common-mistakes-and-strategies" id="toc-common-mistakes-and-strategies">Common Mistakes and Strategies</a></li>
<li><a href="natural-deduction.html#exercises-7" id="toc-exercises-7">Exercises</a></li>
</ul></li>
<li class="has-sub"><a href="identity.html#identity" id="toc-identity"><span class="toc-section-number">9</span> Identity</a>
<ul>
<li><a href="identity.html#syntax-2" id="toc-syntax-2">Syntax</a></li>
<li><a href="identity.html#semantics-2" id="toc-semantics-2">Semantics</a></li>
<li><a href="identity.html#natural-deduction-1" id="toc-natural-deduction-1">Natural Deduction</a></li>
<li><a href="identity.html#uses-of-identity" id="toc-uses-of-identity">Uses of Identity</a></li>
<li><a href="identity.html#exercises-8" id="toc-exercises-8">Exercises</a></li>
</ul></li>
<li class="part"><span><b>IV Appendix</b></span></li>
<li class="has-sub"><a href="solutions-to-selected-exercises.html#solutions-to-selected-exercises" id="toc-solutions-to-selected-exercises"><span class="toc-section-number">10</span> Solutions to Selected Exercises</a>
<ul>
<li><a href="solutions-to-selected-exercises.html#reason-and-argument" id="toc-reason-and-argument">1. Reason and Argument</a></li>
<li><a href="solutions-to-selected-exercises.html#propositional-logic" id="toc-propositional-logic">2. Propositional Logic</a></li>
<li><a href="solutions-to-selected-exercises.html#translation-into-propositional-logic" id="toc-translation-into-propositional-logic">3. Translation into Propositional Logic</a></li>
<li><a href="solutions-to-selected-exercises.html#natural-deduction-for-propositional-logic" id="toc-natural-deduction-for-propositional-logic">4. Natural Deduction for Propositional Logic</a></li>
<li><a href="solutions-to-selected-exercises.html#natural-language-and-propositional-logic-1" id="toc-natural-language-and-propositional-logic-1">5. Natural Language and Propositional Logic</a></li>
<li><a href="solutions-to-selected-exercises.html#quantificational-logic" id="toc-quantificational-logic">6. Quantificational Logic</a></li>
<li><a href="solutions-to-selected-exercises.html#translation-into-quantificational-logic" id="toc-translation-into-quantificational-logic">7. Translation into Quantificational Logic</a></li>
<li><a href="solutions-to-selected-exercises.html#natural-deduction-for-quantificational-logic" id="toc-natural-deduction-for-quantificational-logic">8. Natural Deduction for Quantificational Logic</a></li>
<li><a href="solutions-to-selected-exercises.html#identity-1" id="toc-identity-1">10. Identity</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="formal-language" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Formal Language</h1>
<p>The language of quantificational logic will afford the means to capture the validity of a variety of arguments for which propositional logic appears to be inadequate. We specify:</p>
<ul>
<li><p>a <em>syntax</em> for the language, which will include a vocabulary and a set of grammatical rules designed to specify which expressions are formulas of the language, and</p></li>
<li><p>a <em>semantics</em> for the language, which will explain how to interpret the expressions and formulas of the language and define what is for a formula to be true under a given interpretation.</p></li>
</ul>
<div id="syntax-1" class="section level2 unnumbered">
<h2>Syntax</h2>
<p>We begin with the vocabulary of quantificational logic.</p>
<p><label for="tufte-mn-51" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-51" class="margin-toggle"><span class="marginnote"><span style="display: block;">Vocabulary</span></span></p>
<p>The vocabulary of quantificational logic contains six types of symbol:</p>
<dl>
<dt>Constants</dt>
<dd>
<p>These are the lowercase letters <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, <span class="math inline">\(d\)</span>, and <span class="math inline">\(e\)</span> with or without numerical subscripts:</p>
</dd>
</dl>
<p><span class="math display">\[
   a, b, c, d, e
  \]</span></p>
<dl>
<dt>Predicates</dt>
<dd>
<p>These are uppercase letters <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span>, <span class="math inline">\(S\)</span>, and <span class="math inline">\(T\)</span> with or without numerical subscripts.</p>
</dd>
</dl>
<p><span class="math display">\[
  P, Q, R, S, T
   \dots
   \]</span></p>
<dl>
<dt>Variables</dt>
<dd>
<p>These are lowercase letters <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span> with or without numerical subscripts:</p>
</dd>
</dl>
<p><span class="math display">\[
x, y, z \dots
\]</span></p>
<dl>
<dt>Connectives</dt>
<dd>
<p>These are the symbols:
<span class="math display">\[
\neg, \vee, \wedge, \to
\]</span></p>
</dd>
<dt>Quantifiers</dt>
<dd>
<p>There are two quantifier expressions:
<span class="math display">\[
\forall, \exists
\]</span>
Parentheses</p>
</dd>
<dd>
<p>There are two parentheses:
<span class="math display">\[
), (
\]</span></p>
</dd>
<dd>
<p>Nothing else is a symbol of the language.</p>
</dd>
</dl>
<p><label for="tufte-mn-52" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-52" class="margin-toggle"><span class="marginnote"><span style="display: block;">Grammar</span></span></p>
<p>The grammar of quantificational logic explains how to combine these symbols into formulas of the language. We proceed in two stages.</p>
<dl>
<dt>Atomic Formula</dt>
<dd>
<p>If <span class="math inline">\(P\)</span> is a predicate with <span class="math inline">\(n\)</span> argument places, and each of <span class="math inline">\(\tau_1, \dots, \tau_n\)</span> is a constant or a variable, then
<span class="math display">\[
P\tau_1, \dots, \tau_n
\]</span>
is an <em>atomic formula</em>.</p>
</dd>
</dl>
<p>Atomic formulas are the formal counterparts of simple predications such as ‘Los Angeles is a city’ or ‘Los Angeles is between San Diego and San Francisco’.</p>
<div class="example">
<p><span id="exm:unlabeled-div-55" class="example"><strong>Example 6.1  </strong></span>Each of the expressions below is an atomic formula of quantificational logic:
<span class="math display">\[
\begin{array}{c}
Pxy\\
Qabx\\
Rxaby_3\\
\dots
\end{array}
\]</span></p>
</div>
<p>Atomic formulas provide simple constituents for more complex formulas.</p>
<dl>
<dt>Formula</dt>
<dd>
<p>We now define what is for an expression to be a formula of quantificational logic.</p>
</dd>
</dl>
<div class="info">
<ol style="list-style-type: decimal">
<li>All atomic formulas are <em>formulas</em>.<br />
</li>
<li>If <span class="math inline">\(\varphi\)</span> and <span class="math inline">\(\psi\)</span> are <em>formulas</em>, then each of
<span class="math display">\[
\neg  \varphi, (\varphi \wedge \psi), (\varphi \vee \psi), (\varphi \to \psi)
\]</span>
is a <em>formula</em>.<br />
</li>
<li>If <span class="math inline">\(\varphi\)</span> is a formula and <span class="math inline">\(x\)</span> is a variable, then each of <span class="math inline">\(\forall x \varphi\)</span> and <span class="math inline">\(\exists x \varphi\)</span> is a formula.<br />
</li>
<li>Nothing else is a <em>formula</em>.</li>
</ol>
</div>
<p>We proceed to illustrate the characterization of formula through concrete examples.</p>
<p><label for="tufte-mn-53" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-53" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex-6.2.png"></span>
<span style="display: block;">The construction tree depicts the construction of the formula from
simpler constituents.</span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-56" class="example"><strong>Example 6.2  </strong></span>The expression below is a formula of quantificational logic:
<span class="math display">\[
(\forall x Pxy \to \exists y \ Qab)
\]</span></p>
<ul>
<li>By rule 2, <span class="math inline">\((\forall x Pxy \to \exists y \ Qab)\)</span> is a formula if <span class="math inline">\(\forall x \ Pxy\)</span> and <span class="math inline">\(\exists y \ Qab\)</span> are each a formula.</li>
<li>By rule 3, <span class="math inline">\(\forall x \ Pxy\)</span> is a formula if <span class="math inline">\(Pxy\)</span> is a formula.</li>
<li>By rule 3, <span class="math inline">\(\exists y \ Qab\)</span> is a formula if <span class="math inline">\(Qab\)</span> is a formula.</li>
<li>By rule 1, each <span class="math inline">\(Pxy\)</span> and <span class="math inline">\(Qab\)</span> are formulas, since they are each atomic formulas.</li>
</ul>
<p>Therefore, we conclude that <span class="math inline">\((\forall x Pxy \to \exists y \ Qab)\)</span> is a formula of quantificational logic.</p>
</div>
<p><label for="tufte-mn-54" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-54" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex-6.3.png"></span>
<span style="display: block;">The construction tree depicts the construction of the formula from
simpler constituents.</span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-57" class="example"><strong>Example 6.3  </strong></span>The expression below is a formula of quantificational logic:
<span class="math display">\[
\forall x (Pxy \to Qab)
\]</span></p>
<ul>
<li>By rule 3, <span class="math inline">\(\forall x (Pxy \to Qab)\)</span> is a formula if <span class="math inline">\((Pxy \to Qab)\)</span> is a formula.</li>
<li>By rule 2, <span class="math inline">\((Pxy \to Qab)\)</span> is a formula if each <span class="math inline">\(Pxy\)</span> and <span class="math inline">\(Qab\)</span> are formulas.</li>
<li>By rule 1, each <span class="math inline">\(Pxy\)</span> and <span class="math inline">\(Qab\)</span> are formulas, since they are each atomic formulas.</li>
</ul>
<p>Therefore, we conclude that <span class="math inline">\(\forall x (Pxy \to Qab)\)</span> is a formula of quantificational logic.</p>
</div>
<p>We now make a distinction between two types of occurrences of a variable in a formula. In the formula <span class="math inline">\(\forall x (Qxy \to Ryx)\)</span> the last two occurrences of the variable <span class="math inline">\(x\)</span> match the variable accompanying the quantifier expression, whereas the occurrences of the variable <span class="math inline">\(y\)</span> do not. The occurrences of the variable <span class="math inline">\(x\)</span> have been captured by the initial quantifier, but the occurrences of the variable <span class="math inline">\(y\)</span> remain free.</p>
<p><label for="tufte-mn-55" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-55" class="margin-toggle"><span class="marginnote"><span style="display: block;">Free Occurrences</span></span></p>
<dl>
<dt>Free Occurrence of a Variable</dt>
<dd>
<p>We define what is for an occurrence of a variable to be <em>free</em> in a formula:</p>
</dd>
</dl>
<div class="info">
<ol style="list-style-type: decimal">
<li>All occurrences of a variable in an atomic formula are free.</li>
<li>The free occurrences of a variable in formulas of the form <span class="math inline">\(\varphi\)</span> and <span class="math inline">\(\psi\)</span> remain free when they occur in
<span class="math display">\[
\neg  \varphi, (\varphi \wedge \psi), (\varphi \vee \psi), (\varphi \to \psi)
\]</span></li>
<li>No occurrence of the variable <span class="math inline">\(v\)</span> is free in a formula of the form
<span class="math display">\[
\forall v \varphi, \exists v  \varphi
\]</span>
All occurrences of variables other than <span class="math inline">\(v\)</span> that are free in <span class="math inline">\(\varphi\)</span> remain free in those formulas.</li>
</ol>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-58" class="example"><strong>Example 6.4  </strong></span>The first two occurrences of the variable <span class="math inline">\(x\)</span> occur free in the formula:
<span class="math display">\[
Px \to (Qxy \to \forall x Rxx)
\]</span></p>
<ul>
<li><p>By rule 1, <span class="math inline">\(x\)</span> occurs free in <span class="math inline">\(Px\)</span>, which is an atomic formula, and, by rule 3, the occurrence remains free when it occurs in a conditional of the form <span class="math inline">\(Px \to \psi\)</span>.</p></li>
<li><p>By rule 1, <span class="math inline">\(x\)</span> occurs free in <span class="math inline">\(Qxy\)</span>, which is an atomic formula, and, by rule 2, the occurrence remains free when it occurs in a formula of the form <span class="math inline">\((Qxy \to \psi)\)</span>.</p></li>
<li><p>By rule 2, the last two occurrences of <span class="math inline">\(x\)</span> in <span class="math inline">\(\forall x Rxx\)</span> are not free.</p></li>
</ul>
</div>
<p>An occurrence of a variable is free when it has not been captured by a quantifier. In the last example, the last two occurrences of the variable <span class="math inline">\(x\)</span> are under the scope of the universal quantifier <span class="math inline">\(\forall x\)</span>, whereas the first two occurrences of the variable are not under the scope of a quantifier.</p>
<p><label for="tufte-mn-56" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-56" class="margin-toggle"><span class="marginnote"><span style="display: block;">Bound Occurrences</span></span></p>
<dl>
<dt>Bound Occurrence of a Variable:</dt>
<dd>
<p>An occurrence of a variable in a formula is <em>bound</em> if, and only if, it is not free in that formula.</p>
</dd>
</dl>
<p>A variable occurs <em>freely</em> in a formula if, and only if, some of its occurrences in the formula are <em>free</em>.</p>
<p><label for="tufte-mn-57" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-57" class="margin-toggle"><span class="marginnote"><span style="display: block;">Open and Closed Formulas</span></span></p>
<dl>
<dt>Open and Closed Formulas</dt>
<dd>
<p>A formula is <em>open</em> if, and only if, some variables occur freely in the formula. Otherwise, the formula is <em>closed</em>.</p>
</dd>
</dl>
<div class="example">
<p><span id="exm:unlabeled-div-59" class="example"><strong>Example 6.5  </strong></span>The formula below is open:
<span class="math display">\[
(\forall x \exists y Rxy \vee Qyx)
\]</span>
This is because the last occurrences of the variables <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are free in the formula.</p>
</div>
<div class="example">
<p><span id="exm:unlabeled-div-60" class="example"><strong>Example 6.6  </strong></span>The formula below is closed:
<span class="math display">\[
\forall x \exists y (Rxy \vee Qyx)
\]</span>
The difference with respect to the last formula is that all occurrences of the variables <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span> are now captured by the quantifiers <span class="math inline">\(\exists y\)</span> and <span class="math inline">\(\forall x\)</span>, respectively.</p>
</div>
<dl>
<dt>Notational Convention</dt>
<dd>
<p>We may remove the outer parentheses from a formula that is not part of another formula.</p>
</dd>
</dl>
<p>Notice that this convention will <em>not</em> allow us to omit the parentheses in a formula such as:
<span class="math display">\[
\forall x (Rxa  \to Rax).
\]</span>
For <span class="math inline">\((Rxa  \to Rax)\)</span> is here part of the formula <span class="math inline">\(\forall x (Rxa  \to Rax)\)</span>. Such a formula is importantly different from:
<span class="math display">\[
(\forall x Rxa \to Rax).
\]</span>
The former formula is a <em>closed formula</em> whereas the latter is an <em>open formula</em>, since the last occurrence of the variable <span class="math inline">\(x\)</span> is free in <span class="math inline">\((\forall x Rxa \to Rax)\)</span> as it is not in the scope of the universal quantifier <span class="math inline">\(\forall x\)</span>.</p>
<div class="example">
<p><span id="exm:unlabeled-div-61" class="example"><strong>Example 6.7  </strong></span>We are able to use the expression
<span class="math display">\[
\forall x Rxa \to Rax
\]</span>
is an abbreviation for the formula
<span class="math display">\[
(\forall x Rxa \to Rax)
\]</span></p>
</div>
</div>
<div id="semantics-1" class="section level2 unnumbered">
<h2>Semantics</h2>
<p>We now explain how to interpret the language of quantificational logic. We will not use assignments of truth values to interpret the language but rather models, which will assign a semantic value to the simplest constituents of a formula. A model for quantificational logic includes:</p>
<ul>
<li>a <em>domain</em> of discourse for the quantifiers to range over,</li>
<li>a specification of <em>denotations</em> for the constants of the language, and</li>
<li>a specification of <em>extensions</em> for the predicates of the language</li>
</ul>
<p>The domain of discourse determines the truth conditions of quantified formulas in much the way in which the truth value of a natural language sentence such as ‘I packed everything into my suitcase’ depends on what is the domain of objects over which we take the quantifier ‘everything’ to range. In what follows, we will use a non-empty set of objects as the domain of a model. There are no restrictions on the domain of discourse other than it must contain at least one object.</p>
<p>We will let a model specify denotations for the constants of the language. Constants are formal counterparts of names in natural language, which are generally taken to denote an object in the domain of discourse, e.g., ‘Los Angeles’ denotes a city in Southern California, and ‘Silver Lake’ denotes an area of Los Angeles. A model will assign a member of the domain to each constant of the language as a denotation.</p>
<p>The case of predicates is more subtle. Predicates are formal counterparts of predicate expressions in natural language, which are true of some objects and not of others. Let us begin with one-place predicates such as ‘is red’, which applies to red objects and does not apply to non-red objects. One suggestion at this point is to identify the interpretation of ‘red’ with the <em>set</em> of objects to which the predicate applies. The set of objects to which a given predicate applies is known as the <em>extension</em> of the predicate. Thus the extension of the predicate ‘red’ is the set of red objects and the extension of the predicate ‘human being’ is the set of human beings.</p>
<p>The case of two-place predicates is more complicated. The predicate ‘is south of’ applies to Los Angeles and San Francisco <em>in that order</em> but it fails to apply to San Francisco and Los Angeles <em>in that order</em>. This raises the question of how to specify the extension of the predicate. The answer is to use sets of <em>ordered pairs</em> of objects in the domain, e.g., <span class="math inline">\(\langle LA, SF \rangle\)</span> is the ordered pair of Los Angeles and San Francisco in that order whereas <span class="math inline">\(\langle SF, LA \rangle\)</span> is the ordered pair of San Francisco and Los Angeles in that order. The extension of the two-place predicate ‘is south of’ will be a set of ordered pairs, which contains <span class="math inline">\(\langle LA, SF \rangle\)</span> but not <span class="math inline">\(\langle SF, LA \rangle\)</span>. The solution generalizes to predicates with even more argument places. The interpretation of a three-place predicate is a set of ordered triples, and more generally, the interpretation of an <span class="math inline">\(n\)</span>-place predicate is a set of ordered <span class="math inline">\(n\)</span>-tuples.</p>
<p><label for="tufte-mn-58" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-58" class="margin-toggle"><span class="marginnote"><span style="display: block;">Model</span></span></p>
<dl>
<dt>Model</dt>
<dd>
<p>A model <span class="math inline">\(M\)</span> for quantificational logic is an ordered pair <span class="math inline">\(\langle D, I\rangle\)</span>, where:</p>
</dd>
</dl>
<ul>
<li><span class="math inline">\(D\)</span> is a non-empty set of objects, and</li>
<li><span class="math inline">\(I\)</span> interprets constants and predicates in accordance to the requirements:
<ul>
<li>If <span class="math inline">\(a\)</span> is a constant, <span class="math inline">\(I(a)\)</span> is a member of <span class="math inline">\(D\)</span>.</li>
<li>If <span class="math inline">\(P\)</span> is a one-place predicate, <span class="math inline">\(I(P)\)</span> is a set of members of <span class="math inline">\(P\)</span>.</li>
<li>If <span class="math inline">\(R\)</span> is an <span class="math inline">\(n\)</span>-place predicate, <span class="math inline">\(I(R)\)</span> is a set of <span class="math inline">\(n\)</span>-tuples of members of <span class="math inline">\(D\)</span>.</li>
</ul></li>
</ul>
<p>Given an argument in the language of quantificational logic, we will often consider the question of whether there is an interpretation of the language on which the premises are true and the conclusion false. That amounts to the question whether there is a model for quantificational logic, which verifies the premises but not the conclusion of the argument.</p>
<div class="example">
<p><span id="exm:unlabeled-div-62" class="example"><strong>Example 6.8  </strong></span>Consider the argument given below.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\((Pa \wedge Qb) \to Rab\)</span></li>
<li><span class="math inline">\(\neg Rba\)</span></li>
<li><span class="math inline">\(\exists x (Px \wedge Rxa)\)</span></li>
</ol>
<p>We may evaluate the premises and conclusion of the argument in a model <span class="math inline">\(M\)</span> given by <span class="math inline">\(\langle D, I\rangle\)</span>, where:</p>
<ul>
<li><span class="math inline">\(D = \{1, 2\}\)</span></li>
<li><span class="math inline">\(I(a) = 1\)</span></li>
<li><span class="math inline">\(I(b) = 2\)</span></li>
<li><span class="math inline">\(I(P) = \{1, 2\}\)</span></li>
<li><span class="math inline">\(I(Q) = \{2\}\)</span></li>
<li><span class="math inline">\(I(R) = \{\langle 1, 2\rangle\}\)</span></li>
</ul>
<p>We will eventually explain that the model verifies the premises but not the conclusion of the argument.</p>
</div>
<p>One heuristic you may find helpful for the specification of a model is to use a diagrams as partial representation of the model. The diagram should come accompanied with a key designed to help us specify the interpretation of the relevant constants and predicates.</p>
<p><label for="tufte-mn-59" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-59" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex%206.8.png" style="display:block; margin: 0 auto;"><br />
<span class="math inline"><span class="math inline">\(P :  \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(Q : \text{enclosed by a dark grey
figure}\)</span></span><br />
<span class="math inline"><span class="math inline">\(R : \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span><br />
<span class="math inline"><span class="math inline">\(b : p_2\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-63" class="example"><strong>Example 6.9  </strong></span>The diagram included in the margin encodes the partial specification of a model <span class="math inline">\(\langle D, I\rangle\)</span>, where:</p>
<ul>
<li><span class="math inline">\(D = \{p_1, p_2\}\)</span></li>
<li><span class="math inline">\(I(a) =  p_1\)</span></li>
<li><span class="math inline">\(I(b) = p_2\)</span></li>
<li><span class="math inline">\(I(P) = \text{enclosed by a circle}\)</span></li>
<li><span class="math inline">\(I(Q) = \text{enclosed by a dark grey figure}\)</span></li>
<li><span class="math inline">\(I(R) = \text{points to}\)</span></li>
</ul>
<p>Notice that the diagram comes with a key designed to explain how to interpret each predicate and constant in the diagram.</p>
</div>
<p>This heuristic comes with severe limitations, since some models, e.g., models with an infinite domain, are much too complex to be represented by means of a finite diagram. The method will, however, suffice for <em>some</em> purposes; it will enable us to establish the invalidity of a broad family of arguments in quantificational logic.</p>
<p>The definition of a model makes sure that models provide a semantic value for constants and predicates, but they remain silent when it comes to variables. If constants are the formal counterparts of names in natural language, variables resemble pronouns like ‘he’ or ‘she’, which do not appear to receive a denotation when used in a sentence like ‘If a person likes opera, then she likes classical music.’ For this reason, models do not assign a denotation to variables.</p>
<p>Instead, variables will be treated as temporary labels for members of the domain. That will allow us to evaluate an open formula <span class="math inline">\(Px \wedge Rxy\)</span> relative to an assignment of values to the variables that occur in it. More generally, given a model <span class="math inline">\(M\)</span>, we now explain what is an assignment of members of <span class="math inline">\(M\)</span> to the variables of the language.</p>
<dl>
<dt>Variable Assignment</dt>
<dd>
<p>A <em>variable assignment</em> <span class="math inline">\(\alpha\)</span> over a model <span class="math inline">\(M\)</span> is a map from the range of variables to a members of the domain <span class="math inline">\(D\)</span>.</p>
</dd>
</dl>
<div class="example">
<p><span id="exm:unlabeled-div-64" class="example"><strong>Example 6.10  </strong></span>Each of the maps depicted below are variable assignments over a model <span class="math inline">\(M\)</span> with domain <span class="math inline">\(\{p_1, p_2\}\)</span>:
<span class="math display">\[
\begin{array}{cccccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp; x_2 &amp; y_2 &amp; z_2 &amp; \dots  \\
\hline
p_1 &amp; p_2 &amp; p_1 &amp; p_2 &amp; p_1 &amp; p_2  &amp; p_1 &amp; p_1 &amp; p_2 &amp; \dots \\
\end{array}
\]</span></p>
<p><span class="math display">\[
\begin{array}{cccccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp; x_2 &amp; y_2 &amp; z_2 &amp; \dots  \\
\hline
p_2 &amp; p_1 &amp; p_2 &amp; p_1 &amp; p_2 &amp; p_1  &amp; p_2 &amp; p_1 &amp; p_2 &amp; \dots \\
\end{array}
\]</span>
<span class="math display">\[
\begin{array}{cccccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp; x_2 &amp; y_2 &amp; z_2 &amp; \dots  \\
\hline
p_1 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_1  &amp; p_2 &amp; p_1 &amp; p_2 &amp; \dots \\
\end{array}
\]</span></p>
</div>
<p>Once variable assignments are in place, we are in a position to assign a semantic value to a variable <span class="math inline">\(x\)</span> in a model <span class="math inline">\(M\)</span> <em>relative to an assignment</em> <span class="math inline">\(\alpha\)</span>, which is just <span class="math inline">\(\alpha(x)\)</span>.</p>
<p>For technical reasons, we want to assign semantic values to open formulas in a model relative to a variable assignment over the model. The definition of truth in a model relative to a variable assignment will be inductive: we will define the truth conditions of complex formulas in terms of the truth conditions of simpler ones in much the way with did with the definition of truth under an assignment of truth values to propositional variables in the case of propositional logic. We will begin with an account of the truth conditions of atomic formulas, and we will explain how to assign truth values to more complex sentences in a model relative to an assignment.</p>
<dl>
<dt>Denotation</dt>
<dd>
<p>If <span class="math inline">\(\tau\)</span> is either a constant <span class="math inline">\(c\)</span> or a variable <span class="math inline">\(x\)</span>, the denotation of <span class="math inline">\(\tau\)</span> in a model <span class="math inline">\(M\)</span> under assignment <span class="math inline">\(\alpha\)</span> is <span class="math inline">\(I(c)\)</span> if <span class="math inline">\(\tau\)</span> is a constant <span class="math inline">\(c\)</span> and <span class="math inline">\(\alpha(x)\)</span> if <span class="math inline">\(\tau\)</span> is a variable <span class="math inline">\(x\)</span>.</p>
</dd>
<dt>Atomic Formulas</dt>
<dd>
<p><span class="math inline">\(P\tau\)</span> is true in <span class="math inline">\(M\)</span> under <span class="math inline">\(\alpha\)</span> if the denotation of <span class="math inline">\(\tau\)</span> in <span class="math inline">\(M\)</span> under <span class="math inline">\(\alpha\)</span> is in the extension of <span class="math inline">\(P\)</span>, e.g., <span class="math inline">\(Px\)</span> is true in <span class="math inline">\(M\)</span> under <span class="math inline">\(\alpha\)</span> if <span class="math inline">\(\alpha(x) \in I(P)\)</span> and <span class="math inline">\(Pc\)</span> is true in <span class="math inline">\(M\)</span> under <span class="math inline">\(\alpha\)</span> if <span class="math inline">\(I(c) \in I(P)\)</span>.  More generally, <span class="math inline">\(R\tau_1 \cdots \tau_n\)</span> is true in <span class="math inline">\(M\)</span> under <span class="math inline">\(\alpha\)</span> if the denotations of <span class="math inline">\(\tau_1 \cdots \tau_n\)</span> are in that order in the extension of <span class="math inline">\(R\)</span>, e.g., <span class="math inline">\(Rax\)</span> is true in <span class="math inline">\(M\)</span> under <span class="math inline">\(\alpha\)</span> if <span class="math inline">\(\langle I(a), \alpha(x)\rangle \in I(R)\)</span> .</p>
</dd>
</dl>
<div class="example">
<p><span id="exm:unlabeled-div-65" class="example"><strong>Example 6.11  </strong></span><label for="tufte-mn-60" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-60" class="margin-toggle"><span class="marginnote"><span style="display: block;"><span class="math inline"><span class="math inline">\(D = \{1, 2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(P) = \{1, 2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(Q) = \{2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(R) = \{\langle 1,
2\rangle\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(a) = 1\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(b) = 2\)</span></span></span></span></p>
<p>Let <span class="math inline">\(\alpha\)</span> be an assignment for the model <span class="math inline">\(M\)</span>:
<span class="math display">\[
\begin{array}{cccccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp;  \dots  \\
\hline
1 &amp; 2 &amp; 2 &amp; 2 &amp; 2 &amp; 1  &amp;  \dots \\
\end{array}
\]</span>
Then:</p>
<ul>
<li><span class="math inline">\(Rxy\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(\langle \alpha(x), \alpha(y)\rangle = \langle 1, 2\rangle \in I(R)\)</span>.</li>
<li><span class="math inline">\(Ray\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(\langle I(a), \alpha(y)\rangle = \langle 1, 2\rangle\in I(R)\)</span>.</li>
<li><span class="math inline">\(Px_1\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(\alpha(x_1) \in I(P)\)</span>, that is, <span class="math inline">\(2 \in I(P)\)</span>.</li>
</ul>
</div>
<p>The evaluation of atomic formulas is similar when we use a diagram to specify a model.</p>
<p><label for="tufte-mn-61" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-61" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex%206.8.png" style="display:block; margin: 0 auto;"><br />
<span class="math inline"><span class="math inline">\(P :  \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(Q : \text{enclosed by a dark grey
figure}\)</span></span><br />
<span class="math inline"><span class="math inline">\(R : \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span><br />
<span class="math inline"><span class="math inline">\(b : p_2\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-66" class="example"><strong>Example 6.12  </strong></span>Consider a model <span class="math inline">\(M\)</span> depicted by the diagram, and let <span class="math inline">\(\alpha\)</span> be an assignment of the form:
<span class="math display">\[
\begin{array}{ccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp; \dots  \\
\hline
p_1 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_1  &amp; \dots \\
\end{array}
\]</span>
Then:</p>
<ul>
<li><span class="math inline">\(Rxy\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(\alpha(x)\)</span> points to <span class="math inline">\(\alpha(y)\)</span>. That is, <span class="math inline">\(p_1\)</span> points to <span class="math inline">\(p_2\)</span>.</li>
<li><span class="math inline">\(Ray\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(p_1\)</span> points to <span class="math inline">\(\alpha(y)\)</span>. That is, <span class="math inline">\(p_1\)</span> points to <span class="math inline">\(p_2\)</span>.</li>
<li><span class="math inline">\(Px_1\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(\alpha(x_1)\)</span>, that is, <span class="math inline">\(p_2\)</span>, is enclosed by a circle.</li>
</ul>
</div>
<p>If a complex formula is constructed from simpler formulas by an application of a connective such as <span class="math inline">\(\neg\)</span>, <span class="math inline">\(\wedge\)</span>. <span class="math inline">\(\vee\)</span>, <span class="math inline">\(\to\)</span>, and <span class="math inline">\(\leftrightarrow\)</span>, then its truth conditions in a model <span class="math inline">\(M\)</span> relative to an assignment <span class="math inline">\(\alpha\)</span> are given inductively in the style of the definition of truth for propositional logic. That is,</p>
<dl>
<dt>Negation</dt>
<dd>
<p><span class="math inline">\(\neg  \varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to a variable asignment <span class="math inline">\(\alpha\)</span> if, and only if, <span class="math inline">\(\varphi\)</span> is not true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>.</p>
</dd>
<dt>Conjunction</dt>
<dd>
<p><span class="math inline">\(\varphi \wedge \psi\)</span> is true in <span class="math inline">\(M\)</span> relative to a variable asignment <span class="math inline">\(\alpha\)</span> if, and only if, <span class="math inline">\(\varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\psi\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>.</p>
</dd>
<dt>Disjunction</dt>
<dd>
<p><span class="math inline">\(\varphi \vee \psi\)</span> is true in <span class="math inline">\(M\)</span> relative to a variable asignment <span class="math inline">\(\alpha\)</span> if, and only if, <span class="math inline">\(\varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> or <span class="math inline">\(\psi\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>.</p>
</dd>
<dt>Conditional</dt>
<dd>
<p><span class="math inline">\(\varphi \to \psi\)</span> is true in <span class="math inline">\(M\)</span> relative to a variable asignment <span class="math inline">\(\alpha\)</span> if, and only if, <span class="math inline">\(\varphi\)</span> is not true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> or <span class="math inline">\(\psi\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>.</p>
</dd>
</dl>
<div class="example">
<p><span id="exm:unlabeled-div-67" class="example"><strong>Example 6.13  </strong></span><label for="tufte-mn-62" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-62" class="margin-toggle"><span class="marginnote"><span style="display: block;"><span class="math inline"><span class="math inline">\(D = \{1, 2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(P) = \{1, 2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(Q) = \{2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(R) = \{\langle 1,
2\rangle\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(a) = 1\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(b) = 2\)</span></span></span></span></p>
<p>Let <span class="math inline">\(\alpha\)</span> be an assignment for the model <span class="math inline">\(M\)</span>:
<span class="math display">\[
\begin{array}{cccccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp;  \dots  \\
\hline
1 &amp; 2 &amp; 2 &amp; 2 &amp; 2 &amp; 1  &amp;  \dots \\
\end{array}
\]</span>
Then:</p>
<ul>
<li><span class="math inline">\(Pa \wedge Qb\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(Pa\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(Qb\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>. The former is true because <span class="math inline">\(p_1 \in I(P)\)</span> and the latter is true because <span class="math inline">\(p_2 \in I(Q)\)</span>.</li>
<li><span class="math inline">\((Pa \wedge Qb) \to Rab\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(Rab\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>. This is because <span class="math inline">\(\langle I(a), I(b)\rangle = \langle p_1, p_2 \rangle \in I(R)\)</span>.</li>
<li><span class="math inline">\(\neg Rba\)</span> is in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(Rba\)</span> is <em>not</em> true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>. This is because <span class="math inline">\(\langle I(b), I(a)\rangle = \langle p_2, p_1 \rangle \notin I(R)\)</span>.</li>
</ul>
</div>
<p>The situation is similar for diagramatic representations of a model:</p>
<p><label for="tufte-mn-63" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-63" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex%206.8.png" style="display:block; margin: 0 auto;"><br />
<span class="math inline"><span class="math inline">\(P :  \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(Q : \text{enclosed by a dark grey
figure}\)</span></span><br />
<span class="math inline"><span class="math inline">\(R : \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span><br />
<span class="math inline"><span class="math inline">\(b : p_2\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-68" class="example"><strong>Example 6.14  </strong></span>Consider a model <span class="math inline">\(M\)</span> depicted by the diagram, and let <span class="math inline">\(\alpha\)</span> be an assignment of the form:
<span class="math display">\[
\begin{array}{ccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp; \dots  \\
\hline
p_1 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_1  &amp; \dots \\
\end{array}
\]</span>
Then:</p>
<ul>
<li><span class="math inline">\(Pa \wedge Qb\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(Pa\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(Qb\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>. The former is true because <span class="math inline">\(p_1\)</span> is enclosed by a circle and the latter is true because <span class="math inline">\(p_2\)</span> is enclosed by a grey figure.</li>
<li><span class="math inline">\((Pa \wedge Qb) \to Rab\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(Rab\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>. This is because <span class="math inline">\(I(a)\)</span> points to <span class="math inline">\(I(b)\)</span>. That is, <span class="math inline">\(p_1\)</span> points to <span class="math inline">\(p2\)</span>.</li>
<li><span class="math inline">\(\neg Rba\)</span> is in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because <span class="math inline">\(Rba\)</span> is <em>not</em> true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span>. This is because <span class="math inline">\(I(b)\)</span> does not point to <span class="math inline">\(I(b)\)</span>. That is, <span class="math inline">\(p_2\)</span> does not point to <span class="math inline">\(p1\)</span>.</li>
</ul>
</div>
<p>We now explain how to evaluate quantified formulas of the form <span class="math inline">\(\forall v \varphi\)</span> and <span class="math inline">\(\exists v \varphi\)</span> in a model <span class="math inline">\(M\)</span> relative to a variable assignment over <span class="math inline">\(M\)</span>. We want a formula of the form <span class="math inline">\(\exists x P(x)\)</span> to be true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> if some member of the domain of <span class="math inline">\(M\)</span> lies in the extension of <span class="math inline">\(P\)</span>. One way to achieve this is to declare the formula true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> if there is an object in the domain of <span class="math inline">\(M\)</span> that we can assign to <span class="math inline">\(x\)</span> in order to verify <span class="math inline">\(P(x)\)</span>, which means that there is an assignment <span class="math inline">\(\beta\)</span> which is just like <span class="math inline">\(\alpha\)</span> except perhaps for the fact that it assigns a different object to <span class="math inline">\(x\)</span> such that <span class="math inline">\(P(x)\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\beta\)</span>. Similarly, we want a formula <span class="math inline">\(\forall x P(x)\)</span> to be true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> if every member of the domain of <span class="math inline">\(M\)</span> lies in the extension of <span class="math inline">\(P\)</span>. In other words, <span class="math inline">\(P(x)\)</span> is true in <span class="math inline">\(M\)</span> no matter what we assign to <span class="math inline">\(x\)</span> provided the new variable assignment remains just like <span class="math inline">\(\alpha\)</span> in all other respects.</p>
<dl>
<dt>Existential Quantification</dt>
<dd>
<p><span class="math inline">\(\exists v  \varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to a variable asignment <span class="math inline">\(\alpha\)</span> if, and only if, there is an object <span class="math inline">\(p\)</span> in the domain of <span class="math inline">\(M\)</span> such that <span class="math inline">\(\varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha[x/p]\)</span>, which is an assignment just like <span class="math inline">\(\alpha\)</span> except perhaps for the fact that it assigns <span class="math inline">\(p\)</span> to the variable <span class="math inline">\(x\)</span>.</p>
</dd>
<dt>Universal Quantification</dt>
<dd>
<p><span class="math inline">\(\forall v  \varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to a variable asignment <span class="math inline">\(\alpha\)</span> if, and only if, for every object <span class="math inline">\(p\)</span> in the domain of <span class="math inline">\(M\)</span>, <span class="math inline">\(\varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha[x/p]\)</span>, which is an assignment just like <span class="math inline">\(\alpha\)</span> except perhaps for the fact that it assigns <span class="math inline">\(p\)</span> to the variable <span class="math inline">\(x\)</span>.</p>
</dd>
</dl>
<div class="example">
<p><span id="exm:unlabeled-div-69" class="example"><strong>Example 6.15  </strong></span><label for="tufte-mn-64" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-64" class="margin-toggle"><span class="marginnote"><span style="display: block;"><span class="math inline"><span class="math inline">\(D = \{1, 2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(P) = \{1, 2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(Q) = \{2\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(R) = \{\langle 1,
2\rangle\}\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(a) = 1\)</span></span><br />
<span class="math inline"><span class="math inline">\(I(b) = 2\)</span></span></span></span></p>
<p>Let <span class="math inline">\(\alpha\)</span> be an assignment for the model <span class="math inline">\(M\)</span>:
<span class="math display">\[
\begin{array}{cccccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp;  \dots  \\
\hline
1 &amp; 2 &amp; 2 &amp; 2 &amp; 2 &amp; 1  &amp;  \dots \\
\end{array}
\]</span>
Then:</p>
<ul>
<li><span class="math inline">\(\exists x (Px \wedge \neg Rxa)\)</span> is not true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because there is no member of <span class="math inline">\(D\)</span> we can assign to the variable <span class="math inline">\(x\)</span>, where the new variable assignment remains just like <span class="math inline">\(\alpha\)</span> in all other respects, in order to make <span class="math inline">\(Px \wedge \neg Rxa\)</span> true:
<ul>
<li><span class="math inline">\(\alpha[x/1]\)</span>: <span class="math inline">\(Px \wedge \neg Rxa\)</span> is not true relative to that assignment because <span class="math inline">\(\langle 1, I(a)\rangle \notin I(R)\)</span>.</li>
<li><span class="math inline">\(\alpha[x/2]\)</span>: <span class="math inline">\(Px \wedge \neg Rxa\)</span> is not true relative to that assignment because <span class="math inline">\(\langle 2, I(a)\rangle \notin I(R)\)</span>.</li>
</ul></li>
<li><span class="math inline">\(\forall x Px\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because no matter what member of <span class="math inline">\(D\)</span> assign to the variable <span class="math inline">\(x\)</span>, where the new variable assignment remains just like <span class="math inline">\(\alpha\)</span> in all other respects, we find that <span class="math inline">\(Px\)</span> is true in <span class="math inline">\(M\)</span> relative to the new assignment:</li>
<li><span class="math inline">\(\alpha[x/1]\)</span>: <span class="math inline">\(Px\)</span> is true relative to that assignment because <span class="math inline">\(1 \in I(P)\)</span>.</li>
<li><span class="math inline">\(\alpha[x/2]\)</span>: <span class="math inline">\(Px\)</span> is true relative to that assignment because <span class="math inline">\(2 \in I(P)\)</span>.</li>
</ul>
</div>
<p>The situation is similar for diagramatic representations of a model <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because there is no member of <span class="math inline">\(D\)</span> we can assign to the variable <span class="math inline">\(x\)</span> making sure the new variable assignment remains just like <span class="math inline">\(\alpha\)</span> in all other respects in order to make:</p>
<p><label for="tufte-mn-65" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-65" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex%206.8.png" style="display:block; margin: 0 auto;"><br />
<span class="math inline"><span class="math inline">\(P :  \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(Q : \text{enclosed by a dark grey
figure}\)</span></span><br />
<span class="math inline"><span class="math inline">\(R : \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span><br />
<span class="math inline"><span class="math inline">\(b : p_2\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-70" class="example"><strong>Example 6.16  </strong></span>Consider a model <span class="math inline">\(M\)</span> depicted by the diagram, and let <span class="math inline">\(\alpha\)</span> be an assignment of the form:
<span class="math display">\[
\begin{array}{ccccccc}
x  &amp; y &amp; z &amp; x_1 &amp;  y_1 &amp; z_1 &amp; \dots  \\
\hline
p_1 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_2 &amp; p_1  &amp; \dots \\
\end{array}
\]</span>
Then:</p>
<ul>
<li><span class="math inline">\(\exists x (Px \wedge \neg Rxa)\)</span> is not true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because there is no member of <span class="math inline">\(D\)</span> we can assign to the variable <span class="math inline">\(x\)</span> making sure the new variable assignment remains just like <span class="math inline">\(\alpha\)</span> in all other respects in order to make: <span class="math inline">\(Px \wedge \neg Rxa\)</span>:
<ul>
<li><span class="math inline">\(\alpha[x/p_1]\)</span>: <span class="math inline">\(Px \wedge \neg Rxa\)</span> is not true relative to that assignment because <span class="math inline">\(p_1\)</span> does not point to <span class="math inline">\(p_1\)</span>.</li>
<li><span class="math inline">\(\alpha[x/p_2]\)</span>: <span class="math inline">\(Px \wedge \neg Rxa\)</span> is not true relative to that assignment because <span class="math inline">\(p_2\)</span> does not point to <span class="math inline">\(p_1\)</span>.</li>
</ul></li>
<li><span class="math inline">\(\forall x Px\)</span> is true in <span class="math inline">\(M\)</span> relative to <span class="math inline">\(\alpha\)</span> because no matter what member of <span class="math inline">\(D\)</span> assign to the variable <span class="math inline">\(x\)</span>, where the new variable assignment remains just like <span class="math inline">\(\alpha\)</span> in all other respects, we find that <span class="math inline">\(Px\)</span> is true in <span class="math inline">\(M\)</span> relative to the new assignment:
<ul>
<li><span class="math inline">\(\alpha[x/p_1]\)</span>: <span class="math inline">\(Px\)</span> is true relative to that assignment because <span class="math inline">\(p_1\)</span> is enclosed by a circle.</li>
<li><span class="math inline">\(\alpha[x/p_2]\)</span>: <span class="math inline">\(Px\)</span> is true relative to that assignment because <span class="math inline">\(p_2\)</span> is enclosed by a circle.<br />
</li>
</ul></li>
</ul>
</div>
<p>Once we define what is for a formula <span class="math inline">\(\varphi\)</span> to be true in a model <span class="math inline">\(M\)</span> relative to an assignment <span class="math inline">\(\alpha\)</span>, we are in a position to define what is for a formula <span class="math inline">\(\varphi\)</span> to be true in a model <span class="math inline">\(M\)</span>.</p>
<dl>
<dt>Truth in a Model</dt>
<dd>
<p>A formula <span class="math inline">\(\varphi\)</span> is <em>true in a model</em> <span class="math inline">\(M\)</span> if, and only if, <span class="math inline">\(\varphi\)</span> is true in <span class="math inline">\(M\)</span> relative to <em>all</em> variable assignments over <span class="math inline">\(M\)</span>.</p>
</dd>
<dt>Logical Truth</dt>
<dd>
<p>A formula <span class="math inline">\(\varphi\)</span> of quantificational logic is a <em>logical truth</em> if, and only if, <span class="math inline">\(\varphi\)</span> is true in every model.</p>
</dd>
</dl>
<p>One difference between propositional logic and quantificational logic is that we are not in a position to survey all interpretations of the language in order to determine whether a formula is a logical truth. There is an infinity of domains of discourse to consider and there are different interpretations available for the constants and predicates of the language available for each such domain. The generalization of the tableaux method will provide us with an indirect method for establishing the logical truth of a formula, but in the meantime, all we are in a position to do is to find a counterexample model when a formula is <em>not</em> a logical truth.</p>
<p><label for="tufte-mn-66" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-66" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex%206.19.png" style="display:block; margin: 0 auto;"><br />
</span>
<span style="display: block;"><span class="math inline"><span class="math inline">\(R : \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-71" class="example"><strong>Example 6.17  </strong></span>The formula <span class="math inline">\(Raa \to \forall x Rxa\)</span> is <em>not</em> a logical truth.</p>
<p>The model depicted by the diagram verifies the antecedent of the conditional <span class="math inline">\(Raa\)</span> but it falsifies the consequent <span class="math inline">\(\forall x Rax\)</span>.</p>
<ul>
<li><p>The atomic formula <span class="math inline">\(Raa\)</span> is true in the model because <span class="math inline">\(p_1\)</span> points to itself.</p></li>
<li><p><span class="math inline">\(\forall x Rax\)</span> is not true in the model because <span class="math inline">\(Rax\)</span> does <em>not</em> remain true no matter what value we assign to <span class="math inline">\(x\)</span>, e.g., <span class="math inline">\(Rax\)</span> is not true relative to an assignment on which <span class="math inline">\(x\)</span> denotes <span class="math inline">\(p_2\)</span>.</p></li>
</ul>
</div>
<dl>
<dt>Equivalence</dt>
<dd>
<p>Two formulas <span class="math inline">\(\varphi\)</span> and <span class="math inline">\(\psi\)</span> of quantificational logic are <em>equivalent</em> if, and only if, they are true in exactly the same models.</p>
</dd>
</dl>
<p>We find ourselves in a similar situation. We are not yet in a position to establish that two formulas are logically equivalent, but if they are not, we may set out to find a counterexample in the form of a model in which one formula is true and the other one is false.</p>
<p><label for="tufte-mn-67" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-67" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex-6.20.png" style="display:block; margin: 0 auto;"><br />
</span>
<span style="display: block;"><span class="math inline"><span class="math inline">\(P: \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(Q: \text{enclosed by a diamond}\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-72" class="example"><strong>Example 6.18  </strong></span>The formulas <span class="math inline">\(\exists x Px \wedge \exists x Qx\)</span> and <span class="math inline">\(\exists x (Px \wedge Qx)\)</span> are <em>not</em> a logically equivalent.</p>
<p>The model <span class="math inline">\(M\)</span> depicted by the diagram verifies <span class="math inline">\(\exists x Px \wedge \exists x Qx\)</span> but it falsifies <span class="math inline">\(\exists x (Px \wedge Qx)\)</span>.</p>
<ul>
<li><p>The conjunction <span class="math inline">\(\exists x Px \wedge \exists x Qx\)</span> is true in the model because each conjunct is true in the model. <span class="math inline">\(\exists x Px\)</span> is true in the model because <span class="math inline">\(Px\)</span> is true when <span class="math inline">\(p_1\)</span> is assigned to <span class="math inline">\(x\)</span>, and <span class="math inline">\(\exists x Qx\)</span> is true in the model because <span class="math inline">\(Qx\)</span> is true when <span class="math inline">\(p_2\)</span> is assigned to <span class="math inline">\(x\)</span>.</p></li>
<li><p>The existential quantification <span class="math inline">\(\exists x (Px \wedge Qx)\)</span> is not true in the model because the conjunction <span class="math inline">\(Px \wedge Qx\)</span> is never true no matter what we may assign to the variable <span class="math inline">\(x\)</span>.</p></li>
</ul>
</div>
<dl>
<dt>Consistency</dt>
<dd>
<p>A set of formulas <span class="math inline">\(S\)</span> of quantificational logic is <em>consistent</em> if, and only if, there is at least one model in which all of its members are true. Otherwise, the set is <em>inconsistent</em>.</p>
</dd>
</dl>
<p>If a set of formulas is consistent, then we are in a position to search for a model in which all of their members are true, but it is a different matter to conclusively establish that a set of sentences is inconsistent.</p>
<p><label for="tufte-mn-68" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-68" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex%206.21.png" style="display:block; margin: 0 auto;"><br />
</span>
<span style="display: block;"><span class="math inline"><span class="math inline">\(P: \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(Q: \text{enclosed by a dark grey
figure}\)</span></span><br />
<span class="math inline"><span class="math inline">\(R: \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span><br />
<span class="math inline"><span class="math inline">\(b : p_2\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-73" class="example"><strong>Example 6.19  </strong></span>The set of formulas <span class="math inline">\(\{R(a,b), P(a), Q(b), \exists x (P(x) \wedge Q(x)\}\)</span> is consistent.</p>
<p>All these formulas are true in the model depicted by the diagram:</p>
<ul>
<li><p><span class="math inline">\(Rab\)</span> is true in the model because the denotation of <span class="math inline">\(a\)</span> points to that of <span class="math inline">\(b\)</span>. That is, <span class="math inline">\(p_1\)</span> points to <span class="math inline">\(p_2\)</span>.</p></li>
<li><p><span class="math inline">\(Pa\)</span> is true because the denotation of <span class="math inline">\(a\)</span>, namely, <span class="math inline">\(p_1\)</span>, is enclosed by a circle.</p></li>
<li><p><span class="math inline">\(Qb\)</span> is true because the denotation of <span class="math inline">\(b\)</span>, namely, <span class="math inline">\(p_2\)</span>, is enclosed by a dark grey figure.</p></li>
<li><p><span class="math inline">\(\exists x (Px \wedge Qx)\)</span> is true in the model because the conjunction <span class="math inline">\(Px \wedge Qx\)</span> is true when we assign a member of the domain, namely, <span class="math inline">\(p_2\)</span>, to the variable <span class="math inline">\(x\)</span>.</p></li>
</ul>
</div>
<dl>
<dt>Validity</dt>
<dd>
<p>An argument of quantificational logic is <em>valid</em> if, and only if, there is no model which all of its premises are true while its conclusion is false. Otherwise, the argument is <em>invalid</em>.</p>
</dd>
</dl>
<p>If an argument is not valid, then we are in a position to search for a model in which the premises are true and the conclusion is false. Otherwise, we will have to rely on a generalization of the tableaux method in order to establish validity.</p>
<p><label for="tufte-mn-69" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-69" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/ex%206.8.png" style="display:block; margin: 0 auto;"><br />
</span>
<span style="display: block;"><span class="math inline"><span class="math inline">\(P :  \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(Q : \text{enclosed by a dark grey
figure}\)</span></span><br />
<span class="math inline"><span class="math inline">\(R : \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span><br />
<span class="math inline"><span class="math inline">\(b : p_2\)</span></span></span></span></p>
<div class="example">
<p><span id="exm:unlabeled-div-74" class="example"><strong>Example 6.20  </strong></span>Consider the following argument:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\((P(a) \wedge Q(b)) \to R(a,b)\)</span></li>
<li><span class="math inline">\(\neg R(b,a)\)</span></li>
<li><span class="math inline">\(\exists x (P(x) \wedge R(x,a))\)</span></li>
</ol>
<p>The model depicted by the diagram verifies the premises of the argument but falsifies the conclusion.</p>
<ul>
<li><p>The conditional <span class="math inline">\((Pa \wedge Qb) \to Rab\)</span> is true in the model because its consequent <span class="math inline">\(Rab\)</span> is true in the model.</p></li>
<li><p>The negation <span class="math inline">\(\neg Rba\)</span> is true in the model because the denotation of <span class="math inline">\(b\)</span>, namely, <span class="math inline">\(p_2\)</span> does not point to the denotation of <span class="math inline">\(a\)</span>, namely, <span class="math inline">\(p_1\)</span>.</p></li>
<li><p>The existential quantification <span class="math inline">\(\exists x (Px \wedge Rxa)\)</span> is false in the model because the conjunction <span class="math inline">\(Px \wedge Rxa)\)</span> is never true no matter what we assign to the variable <span class="math inline">\(x\)</span>.</p></li>
</ul>
</div>
</div>
<div id="exercises-5" class="section level2 unnumbered">
<h2>Exercises</h2>
<ol style="list-style-type: decimal">
<li><p>Determine whether each of the following expressions is an atomic formula of quantificational logic.</p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">\(\neg Rxy\)</span></p></li>
<li><p><span class="math inline">\(Rxy\)</span></p></li>
<li><p><span class="math inline">\(Aabx\)</span></p></li>
<li><p><span class="math inline">\(Qe\)</span></p></li>
<li><p><span class="math inline">\(Pxyza\)</span></p></li>
<li><p><span class="math inline">\(RPa\)</span></p></li>
</ol></li>
<li><p>Determine whether each of the following expressions is a formula of quantificational logic.</p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">\(\neg \neg Rxy\)</span></p></li>
<li><p><span class="math inline">\((Pa \to (Axy \wedge \exists x Qx)\)</span></p></li>
<li><p><span class="math inline">\(\forall x Ryy\)</span></p></li>
<li><p><span class="math inline">\(\exists x y (P \wedge P(y))\)</span></p></li>
<li><p><span class="math inline">\(\forall \forall x Ryx\)</span></p></li>
<li><p><span class="math inline">\(\exists x \exists y Rxy\)</span></p></li>
</ol></li>
<li><p>Determine whether each of the following expressions is an <em>abbreviation</em> for a formula of quantificational logic.</p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">\(\exists x \exists y Rxy \to Px\)</span></p></li>
<li><p><span class="math inline">\(\forall x Rx \vee \exists y Qyy\)</span></p></li>
<li><p><span class="math inline">\(Px \wedge Qx \vee Rxy\)</span></p></li>
<li><p><span class="math inline">\(Px \wedge Qx \to Rxy\)</span></p></li>
<li><p><span class="math inline">\(\exists x Px \wedge \exists y Qy \wedge \exists z Rz\)</span></p></li>
<li><p><span class="math inline">\(\exists x \forall y \exists z (Px \wedge Qy \wedge Rxyz)\)</span></p></li>
</ol></li>
<li><p>Determine whether the following formulas contain a free occurrence of the variable <span class="math inline">\(x\)</span>.</p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">\(\forall x (Rxy  \wedge Ryx)\)</span></p></li>
<li><p><span class="math inline">\(\forall x Rxy \wedge Ryx\)</span></p></li>
<li><p><span class="math inline">\(\exists x (Px \wedge Qx) \to \forall y Rxy\)</span></p></li>
<li><p><span class="math inline">\(\forall x \exists y  Rxy \to \exists x \forall y  Ryx\)</span></p></li>
<li><p><span class="math inline">\(\forall x \exists y Rxy \to \forall y  Ryx\)</span></p></li>
<li><p><span class="math inline">\(\forall x (\exists y Rxy \to \forall y  Ryx)\)</span></p></li>
</ol></li>
<li><p>Determine whether the following formulas are <em>open</em> or <em>closed</em>. Justify your answers.</p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">\(\forall x Rxy  \wedge Ryxz\)</span></p></li>
<li><p><span class="math inline">\(Rab\)</span></p></li>
<li><p><span class="math inline">\(\exists x (Pax \wedge Qxa) \to \forall y Rxy\)</span></p></li>
<li><p><span class="math inline">\(\forall x Ryy\)</span></p></li>
<li><p><span class="math inline">\(\forall x \exists y \forall z Rxyx\)</span></p></li>
<li><p><span class="math inline">\(Rax \to \forall x Rxx\)</span></p></li>
</ol></li>
<li><p>Determine which of the following formulas are true in the model:
<label for="tufte-mn-70" class="margin-toggle">⊕</label><input type="checkbox" id="tufte-mn-70" class="margin-toggle"><span class="marginnote"><span style="display: block;"><img src="images/prob%206.png" style="display:block; margin: 0 auto;"><br />
</span>
<span style="display: block;"><span class="math inline"><span class="math inline">\(Q : \text{enclosed by a dark grey
figure}\)</span></span><br />
<span class="math inline"><span class="math inline">\(S : \text{enclosed by a
circle}\)</span></span><br />
<span class="math inline"><span class="math inline">\(T : \text{enclosed by a
diamond}\)</span></span><br />
<span class="math inline"><span class="math inline">\(R : \text{points to}\)</span></span><br />
<span class="math inline"><span class="math inline">\(a : p_1\)</span></span><br />
<span class="math inline"><span class="math inline">\(b : p_2\)</span></span></span></span></p>
<ol style="list-style-type: lower-alpha">
<li><p><span class="math inline">\(Rab\)</span></p></li>
<li><p><span class="math inline">\(Rab \to Rbb\)</span></p></li>
<li><p><span class="math inline">\(Pa \wedge  Qb\)</span></p></li>
<li><p><span class="math inline">\(\exists x Sx \wedge \exists x Tx\)</span></p></li>
<li><p><span class="math inline">\(\forall x (\exists y  Rxy \vee \exists y Ryx)\)</span></p></li>
<li><p><span class="math inline">\(\forall x (Sx  \to \exists y (Qy \wedge Rxy))\)</span></p></li>
</ol></li>
</ol>

</div>
</div>
<p style="text-align: center;">
<a href="limits-of-propositional-logic.html"><button class="btn btn-default">Previous</button></a>
<a href="translation.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
